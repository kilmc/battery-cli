#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/cli.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/battery/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/battery/dist/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(/*! cssesc */ \"./node_modules/battery/node_modules/cssesc/cssesc.js\")) :\n\tundefined;\n}(this, (function (exports,cssesc) { 'use strict';\n\n\tcssesc = cssesc && cssesc.hasOwnProperty('default') ? cssesc['default'] : cssesc;\n\n\tvar isMergeableObject = function isMergeableObject(value) {\n\t\treturn isNonNullObject(value)\n\t\t\t&& !isSpecial(value)\n\t};\n\n\tfunction isNonNullObject(value) {\n\t\treturn !!value && typeof value === 'object'\n\t}\n\n\tfunction isSpecial(value) {\n\t\tvar stringValue = Object.prototype.toString.call(value);\n\n\t\treturn stringValue === '[object RegExp]'\n\t\t\t|| stringValue === '[object Date]'\n\t\t\t|| isReactElement(value)\n\t}\n\n\t// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\tvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n\tvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n\tfunction isReactElement(value) {\n\t\treturn value.$$typeof === REACT_ELEMENT_TYPE\n\t}\n\n\tfunction emptyTarget(val) {\n\t\treturn Array.isArray(val) ? [] : {}\n\t}\n\n\tfunction cloneUnlessOtherwiseSpecified(value, optionsArgument) {\n\t\tvar clone = !optionsArgument || optionsArgument.clone !== false;\n\n\t\treturn (clone && isMergeableObject(value))\n\t\t\t? deepmerge(emptyTarget(value), value, optionsArgument)\n\t\t\t: value\n\t}\n\n\tfunction defaultArrayMerge(target, source, optionsArgument) {\n\t\treturn target.concat(source).map(function(element) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(element, optionsArgument)\n\t\t})\n\t}\n\n\tfunction mergeObject(target, source, optionsArgument) {\n\t\tvar destination = {};\n\t\tif (isMergeableObject(target)) {\n\t\t\tObject.keys(target).forEach(function(key) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument);\n\t\t\t});\n\t\t}\n\t\tObject.keys(source).forEach(function(key) {\n\t\t\tif (!isMergeableObject(source[key]) || !target[key]) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument);\n\t\t\t} else {\n\t\t\t\tdestination[key] = deepmerge(target[key], source[key], optionsArgument);\n\t\t\t}\n\t\t});\n\t\treturn destination\n\t}\n\n\tfunction deepmerge(target, source, optionsArgument) {\n\t\tvar sourceIsArray = Array.isArray(source);\n\t\tvar targetIsArray = Array.isArray(target);\n\t\tvar options = optionsArgument || { arrayMerge: defaultArrayMerge };\n\t\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\t\tif (!sourceAndTargetTypesMatch) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(source, optionsArgument)\n\t\t} else if (sourceIsArray) {\n\t\t\tvar arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\t\treturn arrayMerge(target, source, optionsArgument)\n\t\t} else {\n\t\t\treturn mergeObject(target, source, optionsArgument)\n\t\t}\n\t}\n\n\tdeepmerge.all = function deepmergeAll(array, optionsArgument) {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error('first argument should be an array')\n\t\t}\n\n\t\treturn array.reduce(function(prev, next) {\n\t\t\treturn deepmerge(prev, next, optionsArgument)\n\t\t}, {})\n\t};\n\n\tvar deepmerge_1 = deepmerge;\n\n\t// Strings\n\n\t// Arrays\n\t// ------------------------------------------------------------------\n\tvar subtractArrays = function subtractArrays(arr1, arr2) {\n\t  var returnArr = arr1;\n\n\t  arr2.map(function (remove) {\n\t    var index = arr1.indexOf(remove);\n\t    if (index !== -1) {\n\t      returnArr.splice(index, 1);\n\t    }\n\t  });\n\t  return returnArr;\n\t};\n\n\t// Formatters\n\tvar formatPrefixOrSuffix = function formatPrefixOrSuffix(x, y, prefixOrSuffix) {\n\t  return prefixOrSuffix === 'prefix' ? '' + x + y : '' + y + x;\n\t};\n\n\tvar sortAndJoin = function sortAndJoin(arr) {\n\t  return arr.sort(function (a, b) {\n\t    return b.length - a.length;\n\t  }).join('|');\n\t};\n\n\tvar renameKeys = function renameKeys(obj, filterFn, modifierFn) {\n\t  Object.keys(obj).filter(filterFn).forEach(function (key) {\n\t    obj['' + modifierFn(key)] = obj[key];\n\t    Reflect.deleteProperty(obj, key);\n\t  });\n\t};\n\n\t// getPlugins\n\n\t// getPluginConfigs\n\t// ------------------------------------------------------------------\n\t// Filters propConfigs by enabled[pluginName]\n\n\tvar getPluginPropConfigs = function getPluginPropConfigs(pluginName, propConfigs) {\n\t  return propConfigs.filter(function (prop) {\n\t    return prop.enablePlugin === pluginName;\n\t  });\n\t};\n\n\t// createPluginsObject\n\t// ------------------------------------------------------------------\n\tvar createPluginsObject = function createPluginsObject(plugins) {\n\t  return plugins.reduce(function (accum, plugin) {\n\t    accum[plugin.name] = plugin;\n\t    return accum;\n\t  }, {});\n\t};\n\n\t// getPluginPropNames\n\t// ------------------------------------------------------------------\n\tvar createPropNamesObject = function createPropNamesObject(pluginsObject, propConfigs) {\n\t  return Object.keys(pluginsObject).reduce(function (accum, pluginName) {\n\t    var pluginPropConfigs = getPluginPropConfigs(pluginName, propConfigs);\n\t    var pluginPropNames = pluginPropConfigs.map(function (x) {\n\t      return x.propName;\n\t    });\n\n\t    if (pluginPropNames.length !== 0) {\n\t      accum[pluginName] = pluginPropConfigs.map(function (x) {\n\t        var propName = x.propName,\n\t            _x$separator = x.separator,\n\t            separator = _x$separator === undefined ? '' : _x$separator;\n\n\t        return propName + separator;\n\t      });\n\t    }\n\n\t    return accum;\n\t  }, {});\n\t};\n\n\tvar getPrefixAndSuffixes = function getPrefixAndSuffixes(pluginsConfig) {\n\t  return pluginsConfig.filter(function (x) {\n\t    return x.prefixOrSuffix;\n\t  }).reduce(function (xs, x) {\n\t    var type = x.prefixOrSuffix,\n\t        modifiers = x.modifiers;\n\n\n\t    modifiers.forEach(function (modifier) {\n\t      var indicator = modifier.indicator,\n\t          _modifier$separator = modifier.separator,\n\t          separator = _modifier$separator === undefined ? '' : _modifier$separator;\n\n\t      var item = formatPrefixOrSuffix(indicator, separator, type);\n\n\t      if (xs[type]) {\n\t        xs[type] = xs[type].concat(item);\n\t      } else {\n\t        xs[type] = [item];\n\t      }\n\t    });\n\n\t    return xs;\n\t  }, {});\n\t};\n\n\tvar buildPrefixAndSuffixRegex = function buildPrefixAndSuffixRegex(pluginsConfig) {\n\t  var prefixesAndSuffixes = getPrefixAndSuffixes(pluginsConfig);\n\t  var prefixes = prefixesAndSuffixes['prefix'];\n\t  var suffixes = prefixesAndSuffixes['suffix'];\n\t  var prefixSuffixRegexes = {};\n\n\t  if (prefixes) prefixSuffixRegexes['prefix'] = '(^|' + sortAndJoin(prefixes) + ')';\n\t  if (suffixes) prefixSuffixRegexes['suffix'] = '(' + sortAndJoin(suffixes) + '|$)';\n\t  return prefixSuffixRegexes;\n\t};\n\n\tvar PLUGIN_TYPES = {\n\t  PATTERN: 'pattern',\n\t  LOOKUP: 'lookup',\n\t  CLASSNAME: 'classname',\n\t  KEYWORD: 'keyword',\n\t  ATRULE: 'atrule'\n\t};\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\n\tvar defineProperty = function (obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\n\t  return obj;\n\t};\n\n\tvar _extends = Object.assign || function (target) {\n\t  for (var i = 1; i < arguments.length; i++) {\n\t    var source = arguments[i];\n\n\t    for (var key in source) {\n\t      if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t        target[key] = source[key];\n\t      }\n\t    }\n\t  }\n\n\t  return target;\n\t};\n\n\tvar objectWithoutProperties = function (obj, keys) {\n\t  var target = {};\n\n\t  for (var i in obj) {\n\t    if (keys.indexOf(i) >= 0) continue;\n\t    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n\t    target[i] = obj[i];\n\t  }\n\n\t  return target;\n\t};\n\n\tvar slicedToArray = function () {\n\t  function sliceIterator(arr, i) {\n\t    var _arr = [];\n\t    var _n = true;\n\t    var _d = false;\n\t    var _e = undefined;\n\n\t    try {\n\t      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t        _arr.push(_s.value);\n\n\t        if (i && _arr.length === i) break;\n\t      }\n\t    } catch (err) {\n\t      _d = true;\n\t      _e = err;\n\t    } finally {\n\t      try {\n\t        if (!_n && _i[\"return\"]) _i[\"return\"]();\n\t      } finally {\n\t        if (_d) throw _e;\n\t      }\n\t    }\n\n\t    return _arr;\n\t  }\n\n\t  return function (arr, i) {\n\t    if (Array.isArray(arr)) {\n\t      return arr;\n\t    } else if (Symbol.iterator in Object(arr)) {\n\t      return sliceIterator(arr, i);\n\t    } else {\n\t      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t    }\n\t  };\n\t}();\n\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\n\tvar buildValuePluginRegex = function buildValuePluginRegex(pluginConfig) {\n\t  var hasValueModifiers = _typeof(pluginConfig.valueModifiers) === 'object';\n\t  var values = void 0;\n\n\t  if (pluginConfig.type === PLUGIN_TYPES.LOOKUP) {\n\t    values = '(' + sortAndJoin(Object.keys(pluginConfig.values)) + ')';\n\t  } else {\n\t    values = '(' + pluginConfig.valueRegexString + ')';\n\t  }\n\n\t  var valueModifiers = void 0;\n\t  var hasDefaultModifierIndicator = void 0;\n\n\t  if (hasValueModifiers) {\n\t    var modifiersConfigs = pluginConfig.valueModifiers;\n\n\t    hasDefaultModifierIndicator = modifiersConfigs.some(function (x) {\n\t      return x.default === true;\n\t    });\n\n\t    var modifiers = modifiersConfigs.reduce(function (accum, config) {\n\t      var _config$separator = config.separator,\n\t          separator = _config$separator === undefined ? '' : _config$separator,\n\t          indicator = config.indicator;\n\n\t      return accum.concat('' + separator + indicator);\n\t    }, []);\n\n\t    valueModifiers = '(' + sortAndJoin(modifiers) + ')?';\n\n\t    // TODO: This line seems redundant\n\t    if (hasDefaultModifierIndicator) valueModifiers = '' + valueModifiers;\n\t  }\n\t  return '' + values + (hasValueModifiers ? valueModifiers : '()?');\n\t};\n\n\tvar buildClassNameRegexFn$$1 = function buildClassNameRegexFn$$1(pluginsConfig) {\n\t  var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n\t  var prefixAndSuffixes = {};\n\t  var hasPrefixesOrSuffixes = pluginsConfig.filter(function (x) {\n\t    return x.prefixOrSuffix;\n\t  }).length > 0;\n\n\t  if (hasPrefixesOrSuffixes) prefixAndSuffixes = buildPrefixAndSuffixRegex(pluginsConfig);\n\n\t  var start = prefixAndSuffixes['prefix'] ? prefixAndSuffixes['prefix'] : '(^)';\n\n\t  var end = prefixAndSuffixes['suffix'] ? prefixAndSuffixes['suffix'] : '($)';\n\n\t  return function (propNames) {\n\t    return start + '(' + sortAndJoin(propNames) + ')' + body + end;\n\t  };\n\t};\n\n\tvar generateRegexObj = function generateRegexObj(groupName, arr, regexFn) {\n\t  var sorted = arr.sort(function (a, b) {\n\t    return b.length - a.length;\n\t  }).reduce(function (xs, x) {\n\t    !xs[groupName] ? xs[groupName] = [x] : xs[groupName].push(x);\n\n\t    return xs;\n\t  }, {});\n\n\t  Object.keys(sorted).forEach(function (x) {\n\t    sorted[x] = regexFn(sorted[x]);\n\t  });\n\n\t  return sorted;\n\t};\n\n\tvar generateValuePluginRegexObj = function generateValuePluginRegexObj(plugins, propConfigs) {\n\t  var pluginsObject = createPluginsObject(plugins);\n\n\t  var isValuePlugin = function isValuePlugin(x) {\n\t    return pluginsObject[x].type === PLUGIN_TYPES.PATTERN || pluginsObject[x].type === PLUGIN_TYPES.LOOKUP;\n\t  };\n\n\t  var propNamesObject = createPropNamesObject(pluginsObject, propConfigs);\n\n\t  return Object.keys(pluginsObject).filter(isValuePlugin).reduce(function (accum, pluginName) {\n\t    var props = propNamesObject[pluginName];\n\t    var pluginRegexFn = buildClassNameRegexFn$$1(plugins, buildValuePluginRegex(pluginsObject[pluginName]));\n\n\t    accum = deepmerge_1(accum, generateRegexObj(pluginName, props, pluginRegexFn));\n\n\t    return accum;\n\t  }, {});\n\t};\n\n\tvar generateKeywordValueRegexObj = function generateKeywordValueRegexObj(precompiledClassObjects, pluginsConfig) {\n\t  var atomKeys = Object.keys(precompiledClassObjects);\n\t  var regexFn = buildClassNameRegexFn$$1(pluginsConfig);\n\n\t  return generateRegexObj(PLUGIN_TYPES.KEYWORD, atomKeys, regexFn);\n\t};\n\n\tvar generateClassObject = function generateClassObject(_ref) {\n\t  var className = _ref.className,\n\t      cssProps = _ref.cssProps,\n\t      value = _ref.value;\n\n\t  var eachProp = cssProps.split(' ').reduce(function (props, prop) {\n\t    props[prop] = value;\n\t    return props;\n\t  }, {});\n\t  return defineProperty({}, className, eachProp);\n\t};\n\n\tvar getPropConfigValue = function getPropConfigValue(key) {\n\t  return function (cxPropName, propConfigs) {\n\t    if (cxPropName === '') {\n\t      return propConfigs.filter(function (x) {\n\t        return x.pluginDefault === true;\n\t      }).map(function (x) {\n\t        return x[key];\n\t      }).reduce(function (xs, x) {\n\t        return xs.concat(x);\n\t      }, []).filter(function (x) {\n\t        return x !== undefined;\n\t      });\n\t    } else {\n\t      return propConfigs.filter(function (x) {\n\t        var propName = x.propName,\n\t            _x$separator = x.separator,\n\t            separator = _x$separator === undefined ? '' : _x$separator;\n\n\t        return cxPropName === propName + separator;\n\t      }).map(function (x) {\n\t        return x[key];\n\t      }).reduce(function (xs, x) {\n\t        return xs.concat(x);\n\t      }, []).filter(function (x) {\n\t        return x !== undefined;\n\t      });\n\t    }\n\t  };\n\t};\n\n\tvar getProps = getPropConfigValue('prop');\n\n\tvar modifyValue = function modifyValue(value, modifier, pluginConfig) {\n\t  var hasDefaultModifier = pluginConfig.valueModifiers.some(function (x) {\n\t    return x.default === true;\n\t  });\n\t  var modifierValue = void 0;\n\n\t  if (hasDefaultModifier && modifier === undefined) {\n\t    modifier = '';\n\t  }\n\n\t  if (modifier !== undefined) {\n\t    var valueModifier = pluginConfig.valueModifiers.sort(function (a, b) {\n\t      return b.indicator.length - a.indicator.length;\n\t    }).filter(function (x) {\n\t      var _x$separator2 = x.separator,\n\t          separator = _x$separator2 === undefined ? '' : _x$separator2,\n\t          indicator = x.indicator;\n\n\t      var regex = new RegExp('' + (separator + indicator));\n\n\t      if (indicator === '' && modifier !== '') {\n\t        return false;\n\t      } else if (modifier === separator + indicator) {\n\t        return true;\n\t      } else if (regex.test(modifier)) {\n\t        modifierValue = modifier.replace(separator, '');\n\t        return true;\n\t      } else {\n\t        return false;\n\t      }\n\t    })[0];\n\n\t    return valueModifier.modifierFn(value, modifierValue);\n\t  } else {\n\t    return value;\n\t  }\n\t};\n\n\tvar getValue = function getValue(value, modifier, pluginConfig, lookupValues) {\n\t  if (lookupValues) {\n\t    value = lookupValues[value];\n\t  }\n\t  if (pluginConfig.valueModifiers) {\n\t    value = modifyValue(value, modifier, pluginConfig);\n\t  }\n\n\t  return value;\n\t};\n\n\tvar getAllowedValues = getPropConfigValue('allowedValues');\n\tvar getDisallowedValues = getPropConfigValue('disallowedValues');\n\n\tvar isRestrictedValue = function isRestrictedValue(value, propName, propConfigs) {\n\t  var allowedValues = getAllowedValues(propName, propConfigs);\n\t  var disallowedValues = getDisallowedValues(propName, propConfigs);\n\n\t  if (allowedValues.length) return !allowedValues.includes(value);\n\t  if (disallowedValues.length) return disallowedValues.includes(value);\n\t  return false;\n\t};\n\n\tvar convertClassNameToClassObj = function convertClassNameToClassObj(className, sequencedRegexes, pluginConfig, propConfigs, lookupValues) {\n\t  var previouslyMatched = 0;\n\n\t  return Object.keys(sequencedRegexes).reduce(function (zs, pluginName) {\n\t    if (previouslyMatched === 1) return zs;\n\n\t    var regexString = sequencedRegexes[pluginConfig.name];\n\t    if (regexString === undefined) return zs;\n\n\t    var classNameArr = className.match(regexString);\n\t    if (classNameArr === null) return zs;\n\n\t    previouslyMatched = 1;\n\n\t    var propName = classNameArr[2];\n\n\t    var value = classNameArr[3];\n\t    if (isRestrictedValue(value, propName, propConfigs)) return zs;\n\t    var valueModifier = classNameArr[4];\n\n\t    var convertedClassObj = generateClassObject({\n\t      className: className,\n\t      cssProps: getProps(propName, propConfigs).join(''),\n\t      value: getValue(value, valueModifier, pluginConfig, lookupValues)\n\t    });\n\n\t    zs = _extends({}, zs, convertedClassObj);\n\t    return zs;\n\t  }, {});\n\t};\n\n\tfunction sortObjKeysAlphabetically(obj) {\n\t  var ordered = {};\n\t  Object.keys(obj).sort().forEach(function (key) {\n\t    ordered[key] = obj[key];\n\t  });\n\t  return ordered;\n\t}\n\n\tvar convertClassNamestoClassObjs = function convertClassNamestoClassObjs(sortedClassNames, plugins, props) {\n\t  var pluginNames = Object.keys(sortedClassNames);\n\t  var pluginRegexes = generateValuePluginRegexObj(plugins, props);\n\t  var pluginsObject = createPluginsObject(plugins);\n\n\t  var convertedClassNames = pluginNames.reduce(function (xs, pluginName) {\n\t    var classNames = sortedClassNames[pluginName];\n\n\t    if (pluginName === 'keyword') {\n\t      var preCompiledKeywordObjs = generateKeywordValueObjs(props);\n\t      xs = _extends({}, xs, getKeywordClassObjs(classNames, preCompiledKeywordObjs));\n\t    } else {\n\t      var pluginConfig = pluginsObject[pluginName];\n\t      var name = pluginConfig.name,\n\t          values = pluginConfig.values;\n\n\n\t      var propConfigs = getPluginPropConfigs(name, props);\n\n\t      classNames.forEach(function (cx) {\n\t        var convertedClassName = void 0;\n\t        if (values) {\n\t          convertedClassName = convertClassNameToClassObj(cx, pluginRegexes, pluginConfig, propConfigs, values);\n\t        } else {\n\t          convertedClassName = convertClassNameToClassObj(cx, pluginRegexes, pluginConfig, propConfigs);\n\t        }\n\n\t        xs = _extends({}, xs, convertedClassName);\n\t      });\n\t    }\n\n\t    return xs;\n\t  }, {});\n\n\t  return sortObjKeysAlphabetically(convertedClassNames);\n\t};\n\n\tvar generateKeywordValueObjs = function generateKeywordValueObjs(props) {\n\t  var propConfigsWithKeywordValues = Object.keys(props).map(function (prop) {\n\t    return props[prop];\n\t  }).filter(function (propConfig) {\n\t    return _typeof(propConfig.keywordValues) === 'object';\n\t  });\n\n\t  return propConfigsWithKeywordValues.reduce(function (accum, propConfig) {\n\t    var prop = propConfig.prop,\n\t        propName = propConfig.propName,\n\t        _propConfig$keywordVa = propConfig.keywordValues,\n\t        _propConfig$keywordVa2 = _propConfig$keywordVa.separator,\n\t        separator = _propConfig$keywordVa2 === undefined ? '' : _propConfig$keywordVa2,\n\t        values = _propConfig$keywordVa.values;\n\n\n\t    var classNames = Object.keys(values).reduce(function (classObjects, valueName) {\n\t      classObjects = _extends({}, classObjects, generateClassObject({\n\t        className: '' + propName + (valueName === 'default' ? '' : separator + valueName),\n\t        cssProps: prop,\n\t        value: values[valueName]\n\t      }));\n\n\t      return classObjects;\n\t    }, {});\n\n\t    accum = _extends({}, accum, classNames);\n\t    return accum;\n\t  }, {});\n\t};\n\n\tvar getKeywordClassObjs = function getKeywordClassObjs(classNames, precompiledClassObjects) {\n\t  if (!precompiledClassObjects) return null;\n\n\t  var atomKeys = Object.keys(precompiledClassObjects);\n\t  var keywordRegex = new RegExp('(.*?)(' + atomKeys.sort(function (a, b) {\n\t    return b.length - a.length;\n\t  }).join('|') + ')(.*)');\n\n\t  var matchedClassNames = classNames.filter(function (x) {\n\t    return x.match(keywordRegex);\n\t  });\n\n\t  var returnedAtoms = matchedClassNames.reduce(function (accum, cx) {\n\t    var cleanClass = cx.replace(keywordRegex, '$2');\n\n\t    accum[cx] = precompiledClassObjects[cleanClass];\n\t    return accum;\n\t  }, {});\n\n\t  subtractArrays(classNames, matchedClassNames);\n\t  return returnedAtoms;\n\t};\n\n\tvar formatBorderProp = function formatBorderProp(rootProp, subProp) {\n\t  var _rootProp$split = rootProp.split('-'),\n\t      _rootProp$split2 = slicedToArray(_rootProp$split, 2),\n\t      start = _rootProp$split2[0],\n\t      end = _rootProp$split2[1];\n\n\t  return start + '-' + subProp + '-' + end;\n\t};\n\n\tvar convertSubProps = function convertSubProps(config) {\n\t  var propConfigs = config.props;\n\n\n\t  var subPropConfigs = propConfigs.filter(function (x) {\n\t    return _typeof(x.subProps) === 'object';\n\t  });\n\n\t  var convertedPropConfigs = subPropConfigs.map(function (subPropConfig) {\n\t    var prop = subPropConfig.prop,\n\t        propName = subPropConfig.propName,\n\t        subProps = subPropConfig.subProps,\n\t        _subPropConfig$subPro = subPropConfig.subPropSeparator,\n\t        subPropSeparator = _subPropConfig$subPro === undefined ? '' : _subPropConfig$subPro,\n\t        rest = objectWithoutProperties(subPropConfig, ['prop', 'propName', 'subProps', 'subPropSeparator']);\n\n\n\t    return Object.keys(subProps).reduce(function (accumPropConfigs, x) {\n\t      var subProp = subProps[x].split(' ');\n\t      var processedSubProp = prop.match('border-') ? subProp.map(function (y) {\n\t        return formatBorderProp(prop, y);\n\t      }).join(' ') : subProp.map(function (y) {\n\t        return prop + '-' + y;\n\t      }).join(' ');\n\n\t      var newPropConfig = _extends({\n\t        prop: processedSubProp,\n\t        propName: '' + propName + subPropSeparator + x\n\t      }, rest);\n\n\t      return accumPropConfigs.concat(newPropConfig);\n\t    }, []);\n\t  }).reduce(function (accum, x) {\n\t    return accum.concat(x);\n\t  }, []);\n\n\t  return _extends({}, config, {\n\t    props: [].concat(toConsumableArray(config.props), toConsumableArray(convertedPropConfigs))\n\t  });\n\t};\n\tvar processPropConfigs = function processPropConfigs(config) {\n\t  return convertSubProps(config);\n\t};\n\n\tvar processConfig = function processConfig(config) {\n\t  return processPropConfigs(config);\n\t};\n\n\tvar hasMolecules = function hasMolecules(arr, config) {\n\t  return arr.filter(function (x) {\n\t    return config.molecules.expand[x];\n\t  }).length > 0 || arr.filter(function (x) {\n\t    return config.molecules.merge[x];\n\t  }).length > 0;\n\t};\n\n\tvar unboundCleanMolecule = function unboundCleanMolecule(config) {\n\t  return function (cx) {\n\t    var _config$molecules = config.molecules,\n\t        expand = _config$molecules.expand,\n\t        merge = _config$molecules.merge;\n\n\t    var allMolecules = [].concat(toConsumableArray(Object.keys(expand)), toConsumableArray(Object.keys(merge)));\n\t    var regex = new RegExp(buildClassNameRegexFn$$1(config.plugins)(allMolecules));\n\n\t    return cx.replace(regex, '$2');\n\t  };\n\t};\n\n\tvar getAtoms = function getAtoms(moleculesArr, config) {\n\t  var cleanMolecule = unboundCleanMolecule(config);\n\t  var _config$molecules2 = config.molecules,\n\t      expand = _config$molecules2.expand,\n\t      merge = _config$molecules2.merge;\n\n\n\t  return moleculesArr.reduce(function (xs, x) {\n\t    var cx = cleanMolecule(x);\n\t    var gathered = [];\n\n\t    if (expand[cx]) {\n\t      gathered = gathered.concat(expand[cx].split(' '));\n\t    } else if (merge[cx]) {\n\t      gathered = gathered.concat(merge[cx].split(' '));\n\t    } else {\n\t      gathered = gathered.concat(x);\n\t    }\n\n\t    return xs.concat(gathered);\n\t  }, []);\n\t};\n\n\tvar expandMolecules = function expandMolecules(moleculesArr, config) {\n\t  var expandedAtoms = [];\n\n\t  if (expandedAtoms.length < 1) expandedAtoms = getAtoms(moleculesArr, config);\n\t  if (hasMolecules(expandedAtoms, config)) expandedAtoms = expandMolecules(expandedAtoms, config);\n\n\t  return [].concat(toConsumableArray(new Set(expandedAtoms)));\n\t};\n\n\tvar mergeMolecules = function mergeMolecules(classNames, classObjs, config) {\n\t  var _config$molecules3 = config.molecules,\n\t      merge = _config$molecules3.merge,\n\t      expand = _config$molecules3.expand;\n\n\t  var cleanMolecule = unboundCleanMolecule(config);\n\t  return classNames.reduce(function (xs, x) {\n\t    var cx = cleanMolecule(x);\n\t    if (merge[cx]) {\n\t      xs[x] = Object.assign.apply(Object, [{}].concat(toConsumableArray(merge[cx].split(' ').map(function (x) {\n\t        return classObjs[x];\n\t      }))));\n\t    } else if (expand[cx]) {\n\t      xs = _extends({}, xs, mergeMolecules(expand[cx].split(' '), classObjs, config));\n\t    }\n\n\t    return xs;\n\t  }, {});\n\t};\n\n\tvar sortClassNames = function sortClassNames(classNames, sequencedRegexes) {\n\t  return Object.keys(sequencedRegexes).reduce(function (classNameGroups, pluginName) {\n\t    var matchedClassNames = classNames.filter(function (cx) {\n\t      return cx.match(sequencedRegexes[pluginName]);\n\t    });\n\n\t    if (matchedClassNames.length !== 0) {\n\t      if (!classNameGroups[pluginName]) {\n\t        classNameGroups[pluginName] = matchedClassNames;\n\t      } else {\n\t        classNameGroups[pluginName] = [].concat(toConsumableArray(classNameGroups[pluginName]), toConsumableArray(matchedClassNames));\n\t      }\n\t    }\n\t    classNames = subtractArrays(classNames, matchedClassNames);\n\n\t    return classNameGroups;\n\t  }, {});\n\t};\n\n\tvar generateLibrary = function generateLibrary(classNames, config) {\n\t  var _processConfig = processConfig(config),\n\t      props = _processConfig.props,\n\t      settings = _processConfig.settings,\n\t      plugins = _processConfig.plugins;\n\n\t  var expandedMoluecules = [];\n\t  var toProcessClasses = [].concat(toConsumableArray(classNames));\n\n\t  if (config.molecules) {\n\t    expandedMoluecules = expandMolecules(classNames, config);\n\t    toProcessClasses = toProcessClasses.concat(expandedMoluecules);\n\t  }\n\n\t  var classObjs = void 0;\n\t  var keywordValueRegexes = void 0;\n\n\t  // KeywordValues\n\t  if (settings.enableKeywordValues) {\n\t    var keywordValueObjs = generateKeywordValueObjs(props);\n\t    keywordValueRegexes = generateKeywordValueRegexObj(keywordValueObjs, plugins);\n\t  }\n\n\t  var valuePluginRegexes = generateValuePluginRegexObj(plugins, props);\n\t  var pluginRegexes = deepmerge_1(valuePluginRegexes, keywordValueRegexes);\n\t  // Sort classnames\n\t  var sortedClassNames = sortClassNames(toProcessClasses, pluginRegexes);\n\n\t  // Convert sorted classnames into classObjs\n\t  var convertedClassNames = convertClassNamestoClassObjs(sortedClassNames, plugins, props);\n\n\t  classObjs = _extends({}, convertedClassNames);\n\n\t  if (expandedMoluecules.length > 0) {\n\t    classObjs = _extends({}, classObjs, mergeMolecules(classNames, classObjs, config));\n\n\t    subtractArrays([].concat(toConsumableArray(expandedMoluecules)), [].concat(toConsumableArray(classNames))).forEach(function (cx) {\n\t      Reflect.deleteProperty(classObjs, cx);\n\t    });\n\t  }\n\n\t  return classObjs;\n\t};\n\n\tvar processClassNameType = function processClassNameType(classes, pluginConfig) {\n\t  var modifiers = pluginConfig.modifiers,\n\t      prefixOrSuffix = pluginConfig.prefixOrSuffix;\n\n\n\t  modifiers.forEach(function (modifier) {\n\t    var indicator = modifier.indicator,\n\t        separator = modifier.separator,\n\t        modifierFn = modifier.modifierFn;\n\n\n\t    var item = formatPrefixOrSuffix(indicator, separator, prefixOrSuffix);\n\t    var itemRegex = prefixOrSuffix === 'prefix' ? '^' + item : item + '$';\n\n\t    Object.keys(classes).forEach(function (cx) {\n\t      if (new RegExp(itemRegex).test(cx)) {\n\t        classes['' + modifierFn(cx, indicator)] = classes[cx];\n\t        Reflect.deleteProperty(classes, cx);\n\t      }\n\t    });\n\t  });\n\t};\n\n\tvar processClassNameTypes = function processClassNameTypes(library, plugins) {\n\t  var classNamePlugins = plugins.filter(function (x) {\n\t    return x.type === PLUGIN_TYPES.CLASSNAME;\n\t  });\n\n\t  if (classNamePlugins.length > 0) {\n\t    classNamePlugins.forEach(function (pluginConfig) {\n\t      processClassNameType(library, pluginConfig);\n\t    });\n\t  }\n\t};\n\n\tvar generateClass = function generateClass(className, declarations) {\n\t  var classBody = Object.keys(declarations).map(function (prop) {\n\t    return prop + ': ' + declarations[prop] + ';';\n\t  }).join(' ');\n\n\t  return '.' + className + ' { ' + classBody + ' }';\n\t};\n\n\tvar generateClasses = function generateClasses(obj) {\n\t  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t  return Object.keys(obj).map(function (cx) {\n\t    return generateClass(cx, obj[cx]);\n\t  }).join(indent ? '\\n  ' : '\\n');\n\t};\n\n\tvar generateAtRuleCSS = function generateAtRuleCSS(_ref) {\n\t  var atrule = _ref.atrule,\n\t      output = _ref.output,\n\t      library = _ref.library,\n\t      condition = _ref.condition;\n\n\t  var renderedClasses = generateClasses(library, true);\n\t  if (!renderedClasses) return output;\n\t  var renderedAtrule = '\\n@' + atrule + ' ' + condition + ' {\\n  ' + renderedClasses + '\\n}\\n';\n\t  return output += renderedAtrule;\n\t};\n\n\tvar generateAtRule = function generateAtRule(classes, pluginConfig) {\n\t  var modifiers = pluginConfig.modifiers,\n\t      prefixOrSuffix = pluginConfig.prefixOrSuffix;\n\n\n\t  return modifiers.reduce(function (groups, modifier) {\n\t    var indicator = modifier.indicator,\n\t        separator = modifier.separator;\n\n\n\t    var item = formatPrefixOrSuffix(indicator, separator, prefixOrSuffix);\n\t    var itemRegex = prefixOrSuffix === 'prefix' ? '^' + item : item + '$';\n\n\t    var matchedClasses = Object.keys(classes).reduce(function (groupClasses, cx) {\n\t      if (new RegExp(itemRegex).test(cx)) {\n\t        groupClasses[cx] = classes[cx];\n\t        Reflect.deleteProperty(classes, cx);\n\t        return groupClasses;\n\t      } else {\n\t        return groupClasses;\n\t      }\n\t    }, {});\n\n\t    groups[indicator] = _extends({}, groups[indicator], matchedClasses);\n\n\t    return groups;\n\t  }, {});\n\t};\n\n\tvar generateAtRules = function generateAtRules(library, plugins, renderAs) {\n\t  var atrulePlugins = plugins.filter(function (x) {\n\t    return x.type === PLUGIN_TYPES.ATRULE;\n\t  });\n\n\t  var atRuleCSS = '';\n\t  if (atrulePlugins.length > 0) {\n\t    atrulePlugins.forEach(function (pluginConfig) {\n\t      var atrule = pluginConfig.atrule,\n\t          modifiers = pluginConfig.modifiers;\n\n\t      var atruleGroups = generateAtRule(library, pluginConfig);\n\n\t      modifiers.forEach(function (x) {\n\t        var condition = x.condition,\n\t            indicator = x.indicator;\n\n\n\t        processClassNameTypes(atruleGroups[indicator], plugins);\n\n\t        if (renderAs === 'css') {\n\t          atRuleCSS = generateAtRuleCSS({\n\t            atrule: atrule,\n\t            condition: condition,\n\t            library: atruleGroups[indicator],\n\t            output: atRuleCSS\n\t          });\n\t        }\n\t      });\n\t    });\n\t  }\n\t  return atRuleCSS;\n\t};\n\n\tvar processDisallowedCharacters = function processDisallowedCharacters(library) {\n\t  var escape = function escape(str) {\n\t    return cssesc(str, { isIdentifier: true });\n\t  };\n\t  var regex = /^-?[_a-zA-Z]+[_a-zA-Z0-9-]*$/;\n\t  renameKeys(library, function (x) {\n\t    return !x.match(regex);\n\t  }, escape);\n\t};\n\n\tvar generateCSS = function generateCSS(classNames, config) {\n\t  var library = generateLibrary(classNames, config);\n\t  processDisallowedCharacters(library);\n\t  var libraryCSS = '';\n\n\t  libraryCSS += generateAtRules(library, config.plugins, 'css');\n\n\t  processClassNameTypes(library, config.plugins);\n\n\t  libraryCSS = generateClasses(library) + '\\n' + libraryCSS;\n\n\t  return libraryCSS;\n\t};\n\n\texports.generateCSS = generateCSS;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/battery/dist/index.js?");

/***/ }),

/***/ "./node_modules/battery/node_modules/cssesc/cssesc.js":
/*!************************************************************!*\
  !*** ./node_modules/battery/node_modules/cssesc/cssesc.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*! https://mths.be/cssesc v1.0.1 by @mathias */\n\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/;-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/;-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If it’s not a printable ASCII character…\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It’s a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It’s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t\t// Note: `:` could be escaped as `\\:`, but that fails in IE < 8.\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B:]/.test(character)) {\n\t\t\t\tif (!isIdentifier && character == ':') {\n\t\t\t\t\tvalue = character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^_/.test(output)) {\n\t\t\t// Prevent IE6 from ignoring the rule altogether (in case this is for an\n\t\t\t// identifier used as a selector)\n\t\t\toutput = '\\\\_' + output.slice(1);\n\t\t} else if (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they’re redundant. Note that this is only possible if the escape\n\t// sequence isn’t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It’s not safe to remove the space, so don’t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '1.0.1';\n\nmodule.exports = cssesc;\n\n\n//# sourceURL=webpack:///./node_modules/battery/node_modules/cssesc/cssesc.js?");

/***/ }),

/***/ "./node_modules/commander/index.js":
/*!*****************************************!*\
  !*** ./node_modules/commander/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar spawn = __webpack_require__(/*! child_process */ \"child_process\").spawn;\nvar path = __webpack_require__(/*! path */ \"path\");\nvar dirname = path.dirname;\nvar basename = path.basename;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n/**\n * Inherit `Command` from `EventEmitter.prototype`.\n */\n\n__webpack_require__(/*! util */ \"util\").inherits(Command, EventEmitter);\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\n\n/**\n * Expose `Command`.\n */\n\nexports.Command = Command;\n\n/**\n * Expose `Option`.\n */\n\nexports.Option = Option;\n\n/**\n * Initialize a new `Option` with the given `flags` and `description`.\n *\n * @param {String} flags\n * @param {String} description\n * @api public\n */\n\nfunction Option(flags, description) {\n  this.flags = flags;\n  this.required = flags.indexOf('<') >= 0;\n  this.optional = flags.indexOf('[') >= 0;\n  this.bool = flags.indexOf('-no-') === -1;\n  flags = flags.split(/[ ,|]+/);\n  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();\n  this.long = flags.shift();\n  this.description = description || '';\n}\n\n/**\n * Return option name.\n *\n * @return {String}\n * @api private\n */\n\nOption.prototype.name = function() {\n  return this.long\n    .replace('--', '')\n    .replace('no-', '');\n};\n\n/**\n * Return option name, in a camelcase format that can be used\n * as a object attribute key.\n *\n * @return {String}\n * @api private\n */\n\nOption.prototype.attributeName = function() {\n  return camelcase(this.name());\n};\n\n/**\n * Check if `arg` matches the short or long flag.\n *\n * @param {String} arg\n * @return {Boolean}\n * @api private\n */\n\nOption.prototype.is = function(arg) {\n  return this.short === arg || this.long === arg;\n};\n\n/**\n * Initialize a new `Command`.\n *\n * @param {String} name\n * @api public\n */\n\nfunction Command(name) {\n  this.commands = [];\n  this.options = [];\n  this._execs = {};\n  this._allowUnknownOption = false;\n  this._args = [];\n  this._name = name || '';\n}\n\n/**\n * Add command `name`.\n *\n * The `.action()` callback is invoked when the\n * command `name` is specified via __ARGV__,\n * and the remaining arguments are applied to the\n * function for access.\n *\n * When the `name` is \"*\" an un-matched command\n * will be passed as the first arg, followed by\n * the rest of __ARGV__ remaining.\n *\n * Examples:\n *\n *      program\n *        .version('0.0.1')\n *        .option('-C, --chdir <path>', 'change the working directory')\n *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')\n *        .option('-T, --no-tests', 'ignore test hook')\n *\n *      program\n *        .command('setup')\n *        .description('run remote setup commands')\n *        .action(function() {\n *          console.log('setup');\n *        });\n *\n *      program\n *        .command('exec <cmd>')\n *        .description('run the given remote command')\n *        .action(function(cmd) {\n *          console.log('exec \"%s\"', cmd);\n *        });\n *\n *      program\n *        .command('teardown <dir> [otherDirs...]')\n *        .description('run teardown commands')\n *        .action(function(dir, otherDirs) {\n *          console.log('dir \"%s\"', dir);\n *          if (otherDirs) {\n *            otherDirs.forEach(function (oDir) {\n *              console.log('dir \"%s\"', oDir);\n *            });\n *          }\n *        });\n *\n *      program\n *        .command('*')\n *        .description('deploy the given env')\n *        .action(function(env) {\n *          console.log('deploying \"%s\"', env);\n *        });\n *\n *      program.parse(process.argv);\n  *\n * @param {String} name\n * @param {String} [desc] for git-style sub-commands\n * @return {Command} the new command\n * @api public\n */\n\nCommand.prototype.command = function(name, desc, opts) {\n  if (typeof desc === 'object' && desc !== null) {\n    opts = desc;\n    desc = null;\n  }\n  opts = opts || {};\n  var args = name.split(/ +/);\n  var cmd = new Command(args.shift());\n\n  if (desc) {\n    cmd.description(desc);\n    this.executables = true;\n    this._execs[cmd._name] = true;\n    if (opts.isDefault) this.defaultExecutable = cmd._name;\n  }\n  cmd._noHelp = !!opts.noHelp;\n  this.commands.push(cmd);\n  cmd.parseExpectedArgs(args);\n  cmd.parent = this;\n\n  if (desc) return this;\n  return cmd;\n};\n\n/**\n * Define argument syntax for the top-level command.\n *\n * @api public\n */\n\nCommand.prototype.arguments = function(desc) {\n  return this.parseExpectedArgs(desc.split(/ +/));\n};\n\n/**\n * Add an implicit `help [cmd]` subcommand\n * which invokes `--help` for the given command.\n *\n * @api private\n */\n\nCommand.prototype.addImplicitHelpCommand = function() {\n  this.command('help [cmd]', 'display help for [cmd]');\n};\n\n/**\n * Parse expected `args`.\n *\n * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parseExpectedArgs = function(args) {\n  if (!args.length) return;\n  var self = this;\n  args.forEach(function(arg) {\n    var argDetails = {\n      required: false,\n      name: '',\n      variadic: false\n    };\n\n    switch (arg[0]) {\n      case '<':\n        argDetails.required = true;\n        argDetails.name = arg.slice(1, -1);\n        break;\n      case '[':\n        argDetails.name = arg.slice(1, -1);\n        break;\n    }\n\n    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {\n      argDetails.variadic = true;\n      argDetails.name = argDetails.name.slice(0, -3);\n    }\n    if (argDetails.name) {\n      self._args.push(argDetails);\n    }\n  });\n  return this;\n};\n\n/**\n * Register callback `fn` for the command.\n *\n * Examples:\n *\n *      program\n *        .command('help')\n *        .description('display verbose help')\n *        .action(function() {\n *           // output help here\n *        });\n *\n * @param {Function} fn\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.action = function(fn) {\n  var self = this;\n  var listener = function(args, unknown) {\n    // Parse any so-far unknown options\n    args = args || [];\n    unknown = unknown || [];\n\n    var parsed = self.parseOptions(unknown);\n\n    // Output help if necessary\n    outputHelpIfNecessary(self, parsed.unknown);\n\n    // If there are still any unknown options, then we simply\n    // die, unless someone asked for help, in which case we give it\n    // to them, and then we die.\n    if (parsed.unknown.length > 0) {\n      self.unknownOption(parsed.unknown[0]);\n    }\n\n    // Leftover arguments need to be pushed back. Fixes issue #56\n    if (parsed.args.length) args = parsed.args.concat(args);\n\n    self._args.forEach(function(arg, i) {\n      if (arg.required && args[i] == null) {\n        self.missingArgument(arg.name);\n      } else if (arg.variadic) {\n        if (i !== self._args.length - 1) {\n          self.variadicArgNotLast(arg.name);\n        }\n\n        args[i] = args.splice(i);\n      }\n    });\n\n    // Always append ourselves to the end of the arguments,\n    // to make sure we match the number of arguments the user\n    // expects\n    if (self._args.length) {\n      args[self._args.length] = self;\n    } else {\n      args.push(self);\n    }\n\n    fn.apply(self, args);\n  };\n  var parent = this.parent || this;\n  var name = parent === this ? '*' : this._name;\n  parent.on('command:' + name, listener);\n  if (this._alias) parent.on('command:' + this._alias, listener);\n  return this;\n};\n\n/**\n * Define option with `flags`, `description` and optional\n * coercion `fn`.\n *\n * The `flags` string should contain both the short and long flags,\n * separated by comma, a pipe or space. The following are all valid\n * all will output this way when `--help` is used.\n *\n *    \"-p, --pepper\"\n *    \"-p|--pepper\"\n *    \"-p --pepper\"\n *\n * Examples:\n *\n *     // simple boolean defaulting to false\n *     program.option('-p, --pepper', 'add pepper');\n *\n *     --pepper\n *     program.pepper\n *     // => Boolean\n *\n *     // simple boolean defaulting to true\n *     program.option('-C, --no-cheese', 'remove cheese');\n *\n *     program.cheese\n *     // => true\n *\n *     --no-cheese\n *     program.cheese\n *     // => false\n *\n *     // required argument\n *     program.option('-C, --chdir <path>', 'change the working directory');\n *\n *     --chdir /tmp\n *     program.chdir\n *     // => \"/tmp\"\n *\n *     // optional argument\n *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n *\n * @param {String} flags\n * @param {String} description\n * @param {Function|*} [fn] or default\n * @param {*} [defaultValue]\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.option = function(flags, description, fn, defaultValue) {\n  var self = this,\n    option = new Option(flags, description),\n    oname = option.name(),\n    name = option.attributeName();\n\n  // default as 3rd arg\n  if (typeof fn !== 'function') {\n    if (fn instanceof RegExp) {\n      var regex = fn;\n      fn = function(val, def) {\n        var m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n    } else {\n      defaultValue = fn;\n      fn = null;\n    }\n  }\n\n  // preassign default value only for --no-*, [optional], or <required>\n  if (!option.bool || option.optional || option.required) {\n    // when --no-* we make sure default is true\n    if (!option.bool) defaultValue = true;\n    // preassign only if we have a default\n    if (defaultValue !== undefined) {\n      self[name] = defaultValue;\n      option.defaultValue = defaultValue;\n    }\n  }\n\n  // register the option\n  this.options.push(option);\n\n  // when it's passed assign the value\n  // and conditionally invoke the callback\n  this.on('option:' + oname, function(val) {\n    // coercion\n    if (val !== null && fn) {\n      val = fn(val, self[name] === undefined ? defaultValue : self[name]);\n    }\n\n    // unassigned or bool\n    if (typeof self[name] === 'boolean' || typeof self[name] === 'undefined') {\n      // if no value, bool true, and we have a default, then use it!\n      if (val == null) {\n        self[name] = option.bool\n          ? defaultValue || true\n          : false;\n      } else {\n        self[name] = val;\n      }\n    } else if (val !== null) {\n      // reassign\n      self[name] = val;\n    }\n  });\n\n  return this;\n};\n\n/**\n * Allow unknown options on the command line.\n *\n * @param {Boolean} arg if `true` or omitted, no error will be thrown\n * for unknown options.\n * @api public\n */\nCommand.prototype.allowUnknownOption = function(arg) {\n  this._allowUnknownOption = arguments.length === 0 || arg;\n  return this;\n};\n\n/**\n * Parse `argv`, settings options and invoking commands when defined.\n *\n * @param {Array} argv\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.parse = function(argv) {\n  // implicit help\n  if (this.executables) this.addImplicitHelpCommand();\n\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  this._name = this._name || basename(argv[1], '.js');\n\n  // github-style sub-commands with no sub-command\n  if (this.executables && argv.length < 3 && !this.defaultExecutable) {\n    // this user needs help\n    argv.push('--help');\n  }\n\n  // process argv\n  var parsed = this.parseOptions(this.normalize(argv.slice(2)));\n  var args = this.args = parsed.args;\n\n  var result = this.parseArgs(this.args, parsed.unknown);\n\n  // executable sub-commands\n  var name = result.args[0];\n\n  var aliasCommand = null;\n  // check alias of sub commands\n  if (name) {\n    aliasCommand = this.commands.filter(function(command) {\n      return command.alias() === name;\n    })[0];\n  }\n\n  if (this._execs[name] && typeof this._execs[name] !== 'function') {\n    return this.executeSubCommand(argv, args, parsed.unknown);\n  } else if (aliasCommand) {\n    // is alias of a subCommand\n    args[0] = aliasCommand._name;\n    return this.executeSubCommand(argv, args, parsed.unknown);\n  } else if (this.defaultExecutable) {\n    // use the default subcommand\n    args.unshift(this.defaultExecutable);\n    return this.executeSubCommand(argv, args, parsed.unknown);\n  }\n\n  return result;\n};\n\n/**\n * Execute a sub-command executable.\n *\n * @param {Array} argv\n * @param {Array} args\n * @param {Array} unknown\n * @api private\n */\n\nCommand.prototype.executeSubCommand = function(argv, args, unknown) {\n  args = args.concat(unknown);\n\n  if (!args.length) this.help();\n  if (args[0] === 'help' && args.length === 1) this.help();\n\n  // <cmd> --help\n  if (args[0] === 'help') {\n    args[0] = args[1];\n    args[1] = '--help';\n  }\n\n  // executable\n  var f = argv[1];\n  // name of the subcommand, link `pm-install`\n  var bin = basename(f, '.js') + '-' + args[0];\n\n  // In case of globally installed, get the base dir where executable\n  //  subcommand file should be located at\n  var baseDir,\n    link = fs.lstatSync(f).isSymbolicLink() ? fs.readlinkSync(f) : f;\n\n  // when symbolink is relative path\n  if (link !== f && link.charAt(0) !== '/') {\n    link = path.join(dirname(f), link);\n  }\n  baseDir = dirname(link);\n\n  // prefer local `./<bin>` to bin in the $PATH\n  var localBin = path.join(baseDir, bin);\n\n  // whether bin file is a js script with explicit `.js` extension\n  var isExplicitJS = false;\n  if (exists(localBin + '.js')) {\n    bin = localBin + '.js';\n    isExplicitJS = true;\n  } else if (exists(localBin)) {\n    bin = localBin;\n  }\n\n  args = args.slice(1);\n\n  var proc;\n  if (process.platform !== 'win32') {\n    if (isExplicitJS) {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = (process.execArgv || []).concat(args);\n\n      proc = spawn(process.argv[0], args, { stdio: 'inherit', customFds: [0, 1, 2] });\n    } else {\n      proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });\n    }\n  } else {\n    args.unshift(bin);\n    proc = spawn(process.execPath, args, { stdio: 'inherit' });\n  }\n\n  var signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n  signals.forEach(function(signal) {\n    process.on(signal, function() {\n      if (proc.killed === false && proc.exitCode === null) {\n        proc.kill(signal);\n      }\n    });\n  });\n  proc.on('close', process.exit.bind(process));\n  proc.on('error', function(err) {\n    if (err.code === 'ENOENT') {\n      console.error('\\n  %s(1) does not exist, try --help\\n', bin);\n    } else if (err.code === 'EACCES') {\n      console.error('\\n  %s(1) not executable. try chmod or run with root\\n', bin);\n    }\n    process.exit(1);\n  });\n\n  // Store the reference to the child process\n  this.runningCommand = proc;\n};\n\n/**\n * Normalize `args`, splitting joined short flags. For example\n * the arg \"-abc\" is equivalent to \"-a -b -c\".\n * This also normalizes equal sign and splits \"--abc=def\" into \"--abc def\".\n *\n * @param {Array} args\n * @return {Array}\n * @api private\n */\n\nCommand.prototype.normalize = function(args) {\n  var ret = [],\n    arg,\n    lastOpt,\n    index;\n\n  for (var i = 0, len = args.length; i < len; ++i) {\n    arg = args[i];\n    if (i > 0) {\n      lastOpt = this.optionFor(args[i - 1]);\n    }\n\n    if (arg === '--') {\n      // Honor option terminator\n      ret = ret.concat(args.slice(i));\n      break;\n    } else if (lastOpt && lastOpt.required) {\n      ret.push(arg);\n    } else if (arg.length > 1 && arg[0] === '-' && arg[1] !== '-') {\n      arg.slice(1).split('').forEach(function(c) {\n        ret.push('-' + c);\n      });\n    } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {\n      ret.push(arg.slice(0, index), arg.slice(index + 1));\n    } else {\n      ret.push(arg);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Parse command `args`.\n *\n * When listener(s) are available those\n * callbacks are invoked, otherwise the \"*\"\n * event is emitted and those actions are invoked.\n *\n * @param {Array} args\n * @return {Command} for chaining\n * @api private\n */\n\nCommand.prototype.parseArgs = function(args, unknown) {\n  var name;\n\n  if (args.length) {\n    name = args[0];\n    if (this.listeners('command:' + name).length) {\n      this.emit('command:' + args.shift(), args, unknown);\n    } else {\n      this.emit('command:*', args);\n    }\n  } else {\n    outputHelpIfNecessary(this, unknown);\n\n    // If there were no args and we have unknown options,\n    // then they are extraneous and we need to error.\n    if (unknown.length > 0) {\n      this.unknownOption(unknown[0]);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an option matching `arg` if any.\n *\n * @param {String} arg\n * @return {Option}\n * @api private\n */\n\nCommand.prototype.optionFor = function(arg) {\n  for (var i = 0, len = this.options.length; i < len; ++i) {\n    if (this.options[i].is(arg)) {\n      return this.options[i];\n    }\n  }\n};\n\n/**\n * Parse options from `argv` returning `argv`\n * void of these options.\n *\n * @param {Array} argv\n * @return {Array}\n * @api public\n */\n\nCommand.prototype.parseOptions = function(argv) {\n  var args = [],\n    len = argv.length,\n    literal,\n    option,\n    arg;\n\n  var unknownOptions = [];\n\n  // parse options\n  for (var i = 0; i < len; ++i) {\n    arg = argv[i];\n\n    // literal args after --\n    if (literal) {\n      args.push(arg);\n      continue;\n    }\n\n    if (arg === '--') {\n      literal = true;\n      continue;\n    }\n\n    // find matching Option\n    option = this.optionFor(arg);\n\n    // option is defined\n    if (option) {\n      // requires arg\n      if (option.required) {\n        arg = argv[++i];\n        if (arg == null) return this.optionMissingArgument(option);\n        this.emit('option:' + option.name(), arg);\n      // optional arg\n      } else if (option.optional) {\n        arg = argv[i + 1];\n        if (arg == null || (arg[0] === '-' && arg !== '-')) {\n          arg = null;\n        } else {\n          ++i;\n        }\n        this.emit('option:' + option.name(), arg);\n      // bool\n      } else {\n        this.emit('option:' + option.name());\n      }\n      continue;\n    }\n\n    // looks like an option\n    if (arg.length > 1 && arg[0] === '-') {\n      unknownOptions.push(arg);\n\n      // If the next argument looks like it might be\n      // an argument for this option, we pass it on.\n      // If it isn't, then it'll simply be ignored\n      if ((i + 1) < argv.length && argv[i + 1][0] !== '-') {\n        unknownOptions.push(argv[++i]);\n      }\n      continue;\n    }\n\n    // arg\n    args.push(arg);\n  }\n\n  return { args: args, unknown: unknownOptions };\n};\n\n/**\n * Return an object containing options as key-value pairs\n *\n * @return {Object}\n * @api public\n */\nCommand.prototype.opts = function() {\n  var result = {},\n    len = this.options.length;\n\n  for (var i = 0; i < len; i++) {\n    var key = this.options[i].attributeName();\n    result[key] = key === this._versionOptionName ? this._version : this[key];\n  }\n  return result;\n};\n\n/**\n * Argument `name` is missing.\n *\n * @param {String} name\n * @api private\n */\n\nCommand.prototype.missingArgument = function(name) {\n  console.error();\n  console.error(\"  error: missing required argument `%s'\", name);\n  console.error();\n  process.exit(1);\n};\n\n/**\n * `Option` is missing an argument, but received `flag` or nothing.\n *\n * @param {String} option\n * @param {String} flag\n * @api private\n */\n\nCommand.prototype.optionMissingArgument = function(option, flag) {\n  console.error();\n  if (flag) {\n    console.error(\"  error: option `%s' argument missing, got `%s'\", option.flags, flag);\n  } else {\n    console.error(\"  error: option `%s' argument missing\", option.flags);\n  }\n  console.error();\n  process.exit(1);\n};\n\n/**\n * Unknown option `flag`.\n *\n * @param {String} flag\n * @api private\n */\n\nCommand.prototype.unknownOption = function(flag) {\n  if (this._allowUnknownOption) return;\n  console.error();\n  console.error(\"  error: unknown option `%s'\", flag);\n  console.error();\n  process.exit(1);\n};\n\n/**\n * Variadic argument with `name` is not the last argument as required.\n *\n * @param {String} name\n * @api private\n */\n\nCommand.prototype.variadicArgNotLast = function(name) {\n  console.error();\n  console.error(\"  error: variadic arguments must be last `%s'\", name);\n  console.error();\n  process.exit(1);\n};\n\n/**\n * Set the program version to `str`.\n *\n * This method auto-registers the \"-V, --version\" flag\n * which will print the version number when passed.\n *\n * @param {String} str\n * @param {String} [flags]\n * @return {Command} for chaining\n * @api public\n */\n\nCommand.prototype.version = function(str, flags) {\n  if (arguments.length === 0) return this._version;\n  this._version = str;\n  flags = flags || '-V, --version';\n  var versionOption = new Option(flags, 'output the version number');\n  this._versionOptionName = versionOption.long.substr(2) || 'version';\n  this.options.push(versionOption);\n  this.on('option:' + this._versionOptionName, function() {\n    process.stdout.write(str + '\\n');\n    process.exit(0);\n  });\n  return this;\n};\n\n/**\n * Set the description to `str`.\n *\n * @param {String} str\n * @param {Object} argsDescription\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.description = function(str, argsDescription) {\n  if (arguments.length === 0) return this._description;\n  this._description = str;\n  this._argsDescription = argsDescription;\n  return this;\n};\n\n/**\n * Set an alias for the command\n *\n * @param {String} alias\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.alias = function(alias) {\n  var command = this;\n  if (this.commands.length !== 0) {\n    command = this.commands[this.commands.length - 1];\n  }\n\n  if (arguments.length === 0) return command._alias;\n\n  if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n  command._alias = alias;\n  return this;\n};\n\n/**\n * Set / get the command usage `str`.\n *\n * @param {String} str\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.usage = function(str) {\n  var args = this._args.map(function(arg) {\n    return humanReadableArgName(arg);\n  });\n\n  var usage = '[options]' +\n    (this.commands.length ? ' [command]' : '') +\n    (this._args.length ? ' ' + args.join(' ') : '');\n\n  if (arguments.length === 0) return this._usage || usage;\n  this._usage = str;\n\n  return this;\n};\n\n/**\n * Get or set the name of the command\n *\n * @param {String} str\n * @return {String|Command}\n * @api public\n */\n\nCommand.prototype.name = function(str) {\n  if (arguments.length === 0) return this._name;\n  this._name = str;\n  return this;\n};\n\n/**\n * Return prepared commands.\n *\n * @return {Array}\n * @api private\n */\n\nCommand.prototype.prepareCommands = function() {\n  return this.commands.filter(function(cmd) {\n    return !cmd._noHelp;\n  }).map(function(cmd) {\n    var args = cmd._args.map(function(arg) {\n      return humanReadableArgName(arg);\n    }).join(' ');\n\n    return [\n      cmd._name +\n        (cmd._alias ? '|' + cmd._alias : '') +\n        (cmd.options.length ? ' [options]' : '') +\n        (args ? ' ' + args : ''),\n      cmd._description\n    ];\n  });\n};\n\n/**\n * Return the largest command length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestCommandLength = function() {\n  var commands = this.prepareCommands();\n  return commands.reduce(function(max, command) {\n    return Math.max(max, command[0].length);\n  }, 0);\n};\n\n/**\n * Return the largest option length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestOptionLength = function() {\n  var options = [].slice.call(this.options);\n  options.push({\n    flags: '-h, --help'\n  });\n  return options.reduce(function(max, option) {\n    return Math.max(max, option.flags.length);\n  }, 0);\n};\n\n/**\n * Return the largest arg length.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.largestArgLength = function() {\n  return this._args.reduce(function(max, arg) {\n    return Math.max(max, arg.name.length);\n  }, 0);\n};\n\n/**\n * Return the pad width.\n *\n * @return {Number}\n * @api private\n */\n\nCommand.prototype.padWidth = function() {\n  var width = this.largestOptionLength();\n  if (this._argsDescription && this._args.length) {\n    if (this.largestArgLength() > width) {\n      width = this.largestArgLength();\n    }\n  }\n\n  if (this.commands && this.commands.length) {\n    if (this.largestCommandLength() > width) {\n      width = this.largestCommandLength();\n    }\n  }\n\n  return width;\n};\n\n/**\n * Return help for options.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.optionHelp = function() {\n  var width = this.padWidth();\n\n  // Append the help information\n  return this.options.map(function(option) {\n    return pad(option.flags, width) + '  ' + option.description +\n      ((option.bool && option.defaultValue !== undefined) ? ' (default: ' + option.defaultValue + ')' : '');\n  }).concat([pad('-h, --help', width) + '  ' + 'output usage information'])\n    .join('\\n');\n};\n\n/**\n * Return command help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.commandHelp = function() {\n  if (!this.commands.length) return '';\n\n  var commands = this.prepareCommands();\n  var width = this.padWidth();\n\n  return [\n    '  Commands:',\n    '',\n    commands.map(function(cmd) {\n      var desc = cmd[1] ? '  ' + cmd[1] : '';\n      return (desc ? pad(cmd[0], width) : cmd[0]) + desc;\n    }).join('\\n').replace(/^/gm, '    '),\n    ''\n  ].join('\\n');\n};\n\n/**\n * Return program help documentation.\n *\n * @return {String}\n * @api private\n */\n\nCommand.prototype.helpInformation = function() {\n  var desc = [];\n  if (this._description) {\n    desc = [\n      '  ' + this._description,\n      ''\n    ];\n\n    var argsDescription = this._argsDescription;\n    if (argsDescription && this._args.length) {\n      var width = this.padWidth();\n      desc.push('  Arguments:');\n      desc.push('');\n      this._args.forEach(function(arg) {\n        desc.push('    ' + pad(arg.name, width) + '  ' + argsDescription[arg.name]);\n      });\n      desc.push('');\n    }\n  }\n\n  var cmdName = this._name;\n  if (this._alias) {\n    cmdName = cmdName + '|' + this._alias;\n  }\n  var usage = [\n    '',\n    '  Usage: ' + cmdName + ' ' + this.usage(),\n    ''\n  ];\n\n  var cmds = [];\n  var commandHelp = this.commandHelp();\n  if (commandHelp) cmds = [commandHelp];\n\n  var options = [\n    '  Options:',\n    '',\n    '' + this.optionHelp().replace(/^/gm, '    '),\n    ''\n  ];\n\n  return usage\n    .concat(desc)\n    .concat(options)\n    .concat(cmds)\n    .join('\\n');\n};\n\n/**\n * Output help information for this command\n *\n * @api public\n */\n\nCommand.prototype.outputHelp = function(cb) {\n  if (!cb) {\n    cb = function(passthru) {\n      return passthru;\n    };\n  }\n  process.stdout.write(cb(this.helpInformation()));\n  this.emit('--help');\n};\n\n/**\n * Output help information and exit.\n *\n * @api public\n */\n\nCommand.prototype.help = function(cb) {\n  this.outputHelp(cb);\n  process.exit();\n};\n\n/**\n * Camel-case the given `flag`\n *\n * @param {String} flag\n * @return {String}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce(function(str, word) {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Pad `str` to `width`.\n *\n * @param {String} str\n * @param {Number} width\n * @return {String}\n * @api private\n */\n\nfunction pad(str, width) {\n  var len = Math.max(0, width - str.length);\n  return str + Array(len + 1).join(' ');\n}\n\n/**\n * Output help information if necessary\n *\n * @param {Command} command to output help for\n * @param {Array} array of options to search for -h or --help\n * @api private\n */\n\nfunction outputHelpIfNecessary(cmd, options) {\n  options = options || [];\n  for (var i = 0; i < options.length; i++) {\n    if (options[i] === '--help' || options[i] === '-h') {\n      cmd.outputHelp();\n      process.exit(0);\n    }\n  }\n}\n\n/**\n * Takes an argument an returns its human readable equivalent for help usage.\n *\n * @param {Object} arg\n * @return {String}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\n// for versions before node v0.8 when there weren't `fs.existsSync`\nfunction exists(file) {\n  try {\n    if (fs.statSync(file).isFile()) {\n      return true;\n    }\n  } catch (e) {\n    return false;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/commander/index.js?");

/***/ }),

/***/ "./src/cli.js":
/*!********************!*\
  !*** ./src/cli.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _commander = __webpack_require__(/*! commander */ \"./node_modules/commander/index.js\");\n\nvar _commander2 = _interopRequireDefault(_commander);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _battery = __webpack_require__(/*! battery */ \"./node_modules/battery/dist/index.js\");\n\nvar _parseFiles = __webpack_require__(/*! ./parse-files */ \"./src/parse-files.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar writeCssFile = function writeCssFile(styles, outDir) {\n  _fs2.default.writeFile('styles.css', styles, 'utf8');\n};\n\n_commander2.default.command('build <config>').option('-s --static', 'Parse static HTML files').option('-d --dir <dir>', 'Target directory').option('-o --out-dir <dir>', 'Output directory for the final CSS file').action(function (config, options) {\n  var parsedConfig = require(_path2.default.resolve(config)).default;\n  var targetDir = _path2.default.resolve(options.dir ? options.dir : __dirname);\n  var outDir = _path2.default.resolve(options.outDir ? options.outDir : __dirname);\n  var parseFn = options.static ? _parseFiles.parseHTML : _parseFiles.parseJS;\n  var css = (0, _battery.generateCSS)(parseFn(targetDir), parsedConfig);\n  writeCssFile(css, outDir);\n});\n\n_commander2.default.parse(process.argv);\n\n//# sourceURL=webpack:///./src/cli.js?");

/***/ }),

/***/ "./src/parse-files.js":
/*!****************************!*\
  !*** ./src/parse-files.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJS = exports.parseHTML = undefined;\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar extractClassNames = function extractClassNames(str, regexArr) {\n  var stringMatch = '[\\'\\\"](.*?)[\\'\\\"]';\n\n  return regexArr.map(function (regex) {\n    var matches = str.match(new RegExp(regex, 'g'));\n    if (!matches) return [];\n\n    return matches.map(function (x) {\n      return x.match(new RegExp(regex))[1];\n    }).reduce(function (xs, x) {\n      var dirty = x.match(new RegExp(stringMatch, 'g'));\n      dirty ? xs.push(dirty.map(function (y) {\n        return y.match(new RegExp(stringMatch))[1];\n      })) : xs.push(x.split(' '));\n      return xs;\n    }, []).reduce(function (xs, x) {\n      return xs.concat(x);\n    }, []);\n  }).reduce(function (xs, x) {\n    return xs.concat(x);\n  }, []);\n};\n\nvar classNameParser = function classNameParser(_ref) {\n  var regexArr = _ref.regexArr,\n      fileFilterFn = _ref.fileFilterFn;\n  return function (targetDir) {\n    var files = (0, _utils.getPaths)(_path2.default.resolve(targetDir), fileFilterFn);\n    var extractedClassNames = files.map(function (file) {\n      return extractClassNames(_fs2.default.readFileSync(file, \"utf8\"), regexArr);\n    }).reduce(function (xs, x) {\n      return xs.concat(x);\n    }, []);\n\n    return [].concat(_toConsumableArray(new Set(extractedClassNames)));\n  };\n};\n\nvar parseHTML = exports.parseHTML = classNameParser({\n  regexArr: ['class=[\\\"\\'](.*?)[\\\"\\']'],\n  fileFilterFn: function fileFilterFn(f) {\n    return f.match(/\\.html/);\n  }\n});\n\nvar parseJS = exports.parseJS = classNameParser({\n  regexArr: ['styles\\\\((.*?)\\\\)', 'className=[\\\"\\'](.*?)[\\\"\\']'],\n  fileFilterFn: function fileFilterFn(f) {\n    return f.match(/\\.js/);\n  }\n});\n\n//# sourceURL=webpack:///./src/parse-files.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPaths = exports.walkSync = undefined;\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar walkSync = exports.walkSync = function walkSync(dir) {\n  if (_fs2.default.lstatSync(dir).isDirectory()) {\n    return _fs2.default.readdirSync(dir).map(function (f) {\n      return walkSync(_path2.default.resolve(_path2.default.join(dir, f)));\n    }).reduce(function (xs, x) {\n      return xs.concat(x);\n    }, []);\n  } else {\n    return dir;\n  }\n};\n\nvar getPaths = exports.getPaths = function getPaths(dir) {\n  var filterFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {\n    return x;\n  };\n\n  return walkSync(_path2.default.resolve(dir)).filter(filterFn);\n};\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack:///external_%22child_process%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ })

/******/ });